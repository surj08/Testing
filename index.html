<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golf Group Organizer V4</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' fill='%23FFFFFF'%3E%3Crect width='100' height='100' fill='%234CAF50'/%3E%3C!-- Outer Ring --%3E%3Ccircle cx='50' cy='50' r='30' stroke='%23FFFFFF' stroke-width='4' fill='none'/%3E%3C!-- Golf Ball --%3E%3Ccircle cx='50' cy='35' r='12' fill='%23FFFFFF'/%3E%3C!-- Dimples (simplified) --%3E%3Ccircle cx='45' cy='30' r='1.5' fill='%23CCCCCC'/%3E%3Ccircle cx='55' cy='30' r='1.5' fill='%23CCCCCC'/%3E%3Ccircle cx='50' cy='26' r='1.5' fill='%23CCCCCC'/%3E%3Ccircle cx='43' cy='35' r='1.5' fill='%23CCCCCC'/%3E%3Ccircle cx='57' cy='35' r='1.5' fill='%23CCCCCC'/%3E%3Ccircle cx='47' cy='40' r='1.5' fill='%23CCCCCC'/%3E%3Ccircle cx='53' cy='40' r='1.5' fill='%23CCCCCC'/%3E%3C!-- Tee --%3E%3Cpath d='M47 47 L 47 60 Q 47 63 50 63 Q 53 63 53 60 L 53 47 Z' fill='%23FFFFFF'/%3E%3C!-- Grass --%3E%3Cpath d='M40 63 C 42 60, 45 58, 50 58 S 58 60, 60 63 Z' fill='%23FFFFFF'/%3E%3Cpath d='M42 65 C 44 62, 47 60, 50 60 S 56 62, 58 65 Z' fill='%23FFFFFF' opacity='0.7'/%3E%3C!-- Ground line --%3E%3Cellipse cx='50' cy='64' rx='15' ry='3' fill='%23FFFFFF'/%3E%3C/svg%3E">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles (mostly same as V3/V4) */
        body { font-family: 'Inter', sans-serif; }
        .tab.active { border-bottom-color: #3b82f6; font-weight: 600; color: #3b82f6; }
        .tab-manage-players { border-bottom-color: #6b7280; color: #1f2937; }
        .tab-manage-players.active { border-bottom-color: #10b981; font-weight: 600; color: #10b981; }
        .tab:not(.active):hover { border-bottom-color: #d1d5db; color: #6b7280; }
        input[type=range] { /* Keep for skill sliders */
            -webkit-appearance: none; appearance: none; width: 100%; height: 8px;
            background: #d1d5db; outline: none; opacity: 0.7; transition: opacity .2s;
            border-radius: 9999px;
        }
        input[type=range]:hover { opacity: 1; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 20px; height: 20px;
            background: #3b82f6; cursor: pointer; border-radius: 50%;
        }
        input[type=range]::-moz-range-thumb {
            width: 20px; height: 20px; background: #3b82f6; cursor: pointer;
            border-radius: 50%; border: none;
        }
        /* Style Number Input */
        input[type=number] {
             -moz-appearance: textfield; /* Firefox */
             appearance: textfield;
             border: 1px solid #d1d5db;
             padding: 0.5rem 0.75rem;
             border-radius: 0.375rem; /* rounded-md */
             width: 60px; /* Adjust width as needed */
             text-align: center;
        }
        input[type=number]::-webkit-outer-spin-button,
        input[type=number]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        .group-card, .player-item { transition: all 0.2s ease-in-out; }
        .player-item:hover { background-color: #f3f4f6; }
        #search-results {
            max-height: 150px; overflow-y: auto; border: 1px solid #d1d5db;
            border-top: none; border-radius: 0 0 0.375rem 0.375rem; background-color: white;
            position: absolute; width: 100%; z-index: 10;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .search-result-item { padding: 0.5rem 0.75rem; cursor: pointer; }
        .search-result-item:hover { background-color: #eff6ff; }
        .inline-skill-bar-container {
            display: inline-block; width: 50px; height: 10px; background-color: #e5e7eb;
            border-radius: 5px; overflow: hidden; margin-left: 8px; vertical-align: middle;
        }
        .inline-skill-bar { height: 100%; background-color: #60a5fa; border-radius: 5px 0 0 5px; transition: width 0.3s ease-in-out; }
        .group-skill-bar-container { width: 100%; height: 12px; background-color: #e5e7eb; border-radius: 6px; overflow: hidden; margin-top: 8px; }
        .group-skill-bar { height: 100%; background-color: #34d399; border-radius: 6px 0 0 6px; transition: width 0.3s ease-in-out; text-align: right; padding-right: 5px; font-size: 0.65rem; line-height: 12px; color: white; font-weight: 600; }
        .tooltip-container { position: relative; display: inline-block; }
        .tooltiptext { visibility: hidden; width: max-content; background-color: #374151; color: #fff; text-align: center; border-radius: 6px; padding: 5px 8px; position: absolute; z-index: 1; bottom: 125%; left: 50%; transform: translateX(-50%); opacity: 0; transition: opacity 0.3s; font-size: 0.75rem; white-space: nowrap; }
        .tooltip-container:hover .tooltiptext { visibility: visible; opacity: 1; }
        .icon-btn { cursor: pointer; margin-left: 4px; vertical-align: middle; display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 4px; }
        .icon-btn:hover { background-color: #e5e7eb; }
        .icon-btn svg { width: 12px; height: 12px; }
        .edit-icon { color: #6b7280; } .delete-icon { color: #ef4444; }
        .edit-icon:hover { color: #3b82f6; } .delete-icon:hover { color: #dc2626; }
        .mgmt-player-item { display: flex; justify-content: space-between; align-items: center; padding: 8px; border-bottom: 1px solid #eee; }
        .mgmt-player-item:last-child { border-bottom: none; }

        /* Modal Styles */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); display: flex; align-items: center; justify-content: center; z-index: 50; opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: white; padding: 2rem; border-radius: 0.5rem; box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1); max-width: 400px; width: 90%; transform: scale(0.95); transition: transform 0.3s ease; }
        .modal-overlay.visible .modal-content { transform: scale(1); }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="max-w-6xl mx-auto bg-white rounded-lg shadow-md p-6">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">Golf Group Organizer V4</h1>

        <div class="border-b border-gray-200 mb-6">
            <nav id="tabs" class="-mb-px flex space-x-4 overflow-x-auto pb-1" aria-label="Tabs">
                 <button id="tab-manage-players-btn" class="tab tab-manage-players whitespace-nowrap py-3 px-3 border-b-2 text-sm font-medium rounded-t-md flex-shrink-0">Manage Players</button>
                 <button id="add-outing-btn" class="flex-shrink-0 whitespace-nowrap py-3 px-3 border-b-2 border-transparent text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300 rounded-t-md">+ Add Outing</button>
                 </nav>
        </div>

        <div id="tab-content">

            <div id="outing-view" class="hidden">
                 <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                     <div class="md:col-span-1 space-y-6">
                         <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                             <h2 class="text-lg font-semibold text-gray-700 mb-3">Add Players to Outing</h2>
                             <div class="relative">
                                 <label for="player-search" class="block text-sm font-medium text-gray-700 mb-1">Search Database</label>
                                 <input type="text" id="player-search" placeholder="Start typing player name..." class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                                 <div id="search-results" class="absolute left-0 right-0 mt-1 hidden"></div>
                             </div>
                             <div id="add-new-player-section" class="mt-4 pt-4 border-t border-gray-200 hidden">
                                 <h3 class="text-md font-semibold text-gray-600 mb-2">Add New Player</h3>
                                 <p class="text-sm mb-2">Player "<strong id="new-player-name-display"></strong>" not found.</p>
                                 <div class="mb-3">
                                     <label for="new-player-skill" class="block text-sm font-medium text-gray-700 mb-1">Set Skill Level (<span id="new-skill-value">5</span>)</label>
                                     <input type="range" id="new-player-skill" min="1" max="10" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                 </div>
                                 <button id="add-new-player-btn" class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out">Add New Player to Database</button>
                             </div>
                         </div>

                         <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                             <h2 class="text-lg font-semibold text-gray-700 mb-3">Players in this Outing</h2>
                             <div id="outing-player-list" class="mt-2 max-h-60 overflow-y-auto space-y-1 pr-2">
                                 </div>
                         </div>
                     </div>

                     <div class="md:col-span-2 space-y-6">
                         <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                             <h2 class="text-lg font-semibold text-gray-700 mb-3">Configure Groups</h2>
                              <div class="flex flex-col md:flex-row md:items-center gap-4">
                                 <div class="flex items-center gap-2">
                                      <label for="num-groups" class="block text-sm font-medium text-gray-700">Number of Groups:</label>
                                     <input type="number" id="num-groups" min="1" max="10" step="1" value="3" class="shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                                 </div>
                                 <button id="recalculate-btn" class="mt-2 md:mt-0 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-150 ease-in-out">
                                     Recalculate Groups
                                 </button>
                              </div>
                         </div>

                         <div>
                             <h2 class="text-lg font-semibold text-gray-700 mb-3">Generated Groups</h2>
                             <div id="group-display" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                                 </div>
                         </div>
                     </div>
                 </div>
            </div> <div id="player-management-view" class="hidden">
                  <h2 class="text-xl font-semibold text-gray-700 mb-4">Player Database Management</h2>
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                          <h3 class="text-lg font-semibold text-gray-700 mb-3">Add Player to Database</h3>
                          <div class="space-y-3">
                              <div>
                                  <label for="mgmt-player-name" class="block text-sm font-medium text-gray-700">Player Name</label>
                                  <input type="text" id="mgmt-player-name" placeholder="Enter full name" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                              </div>
                              <div>
                                  <label for="mgmt-player-skill" class="block text-sm font-medium text-gray-700">Skill Level (<span id="mgmt-skill-value">5</span>)</label>
                                  <input type="range" id="mgmt-player-skill" min="1" max="10" value="5" class="mt-1 w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                              </div>
                              <button id="mgmt-add-player-btn" class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out">Add Player</button>
                          </div>
                      </div>
                      <div class="p-4 border border-gray-200 rounded-lg bg-gray-50">
                          <h3 class="text-lg font-semibold text-gray-700 mb-3">All Players</h3>
                          <div id="all-players-list" class="max-h-96 overflow-y-auto space-y-1 pr-2">
                              </div>
                      </div>
                  </div>
            </div> <div id="message-area" class="mt-6 text-center font-medium"></div>

        </div> <div id="edit-player-modal" class="modal-overlay">
            <div class="modal-content">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">Edit Player</h3>
                <input type="hidden" id="edit-player-original-name"> <div class="space-y-4">
                    <div>
                        <label for="edit-player-name" class="block text-sm font-medium text-gray-700">Player Name</label>
                        <input type="text" id="edit-player-name" class="mt-1 w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div>
                        <label for="edit-player-skill" class="block text-sm font-medium text-gray-700">Skill Level (<span id="edit-skill-value">5</span>)</label>
                        <input type="range" id="edit-player-skill" min="1" max="10" value="5" class="mt-1 w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                </div>
                <div class="mt-6 flex justify-end space-x-3">
                    <button id="cancel-edit-player-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400">Cancel</button>
                    <button id="save-edit-player-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">Save Changes</button>
                </div>
            </div>
        </div>

    </div> <script>
        // --- DOM Elements ---
        const tabsContainer = document.getElementById('tabs');
        const managePlayersTabBtn = document.getElementById('tab-manage-players-btn');
        const addOutingBtn = document.getElementById('add-outing-btn');
        const outingViewDiv = document.getElementById('outing-view');
        const playerManagementViewDiv = document.getElementById('player-management-view');
        // Outing View Elements
        const playerSearchInput = document.getElementById('player-search');
        const searchResultsDiv = document.getElementById('search-results');
        const addNewPlayerSection = document.getElementById('add-new-player-section');
        const newPlayerNameDisplay = document.getElementById('new-player-name-display');
        const newPlayerSkillSlider = document.getElementById('new-player-skill');
        const newSkillValueSpan = document.getElementById('new-skill-value');
        const addNewPlayerBtn = document.getElementById('add-new-player-btn');
        const outingPlayerListDiv = document.getElementById('outing-player-list');
        const numGroupsInput = document.getElementById('num-groups'); // Changed from slider
        const recalculateBtn = document.getElementById('recalculate-btn'); // Renamed from shakeUpBtn
        const groupDisplayDiv = document.getElementById('group-display');
        // Player Management View Elements
        const mgmtPlayerNameInput = document.getElementById('mgmt-player-name');
        const mgmtPlayerSkillSlider = document.getElementById('mgmt-player-skill');
        const mgmtSkillValueSpan = document.getElementById('mgmt-skill-value');
        const mgmtAddPlayerBtn = document.getElementById('mgmt-add-player-btn');
        const allPlayersListDiv = document.getElementById('all-players-list');
        // Edit Player Modal Elements
        const editPlayerModal = document.getElementById('edit-player-modal');
        const editPlayerOriginalNameInput = document.getElementById('edit-player-original-name');
        const editPlayerNameInput = document.getElementById('edit-player-name');
        const editPlayerSkillSlider = document.getElementById('edit-player-skill');
        const editSkillValueSpan = document.getElementById('edit-skill-value');
        const cancelEditPlayerBtn = document.getElementById('cancel-edit-player-btn');
        const saveEditPlayerBtn = document.getElementById('save-edit-player-btn');
        // Global Elements
        const messageArea = document.getElementById('message-area');

        // --- Application State ---
        let allPlayers = {}; // Stores player objects, key is player ID (UUID)
                             // Example: { "uuid-123": { id: "uuid-123", name: "John Doe", name_lower: "john doe", skill: 7 } }
        let outings = {};    // Stores outing objects, key is outing ID (UUID)
                             // Example: { "uuid-abc": { id: "uuid-abc", name: "Weekend Game", number_of_groups: 3, playerIds: ["uuid-123"], groups: [] } }
        let activeOutingId = null; // Stores the ID of the currently viewed/managed outing
        let currentViewMode = 'outing'; // or 'playerManagement'
        // nextOutingIndex is removed.

        // --- Constants ---
        const PLAYER_MGMT_VIEW_ID = 'playerManagement';
        const GOLF_GROUP_NAMES = [ // Fun names for groups
            "The Eagles", "Fairway Finders", "Team Bogey", "The Birdies", "Sand Trappers",
            "Long Drivers", "Putt Pirates", "The Mulligans", "Chip Shots", "Green Jackets",
            "Hole-in-Ones", "Pin Seekers", "The Caddies", "Divot Diggers", "Slice Squad"
        ];

        // --- API Helper ---
        async function fetchAPI(url, options = {}) {
            const defaultHeaders = {
                'Content-Type': 'application/json',
            };
            const config = {
                ...options,
                headers: {
                    ...defaultHeaders,
                    ...options.headers,
                },
            };

            try {
                const response = await fetch(url, config);
                if (!response.ok) {
                    // Try to parse error response as JSON, but fallback if it's not
                    const errorData = await response.json().catch(() => ({ message: response.statusText, details: `Response status: ${response.status}` }));
                    const error = new Error(errorData.message || `HTTP error! status: ${response.status}`);
                    error.data = errorData; // Attach full error data if available
                    error.status = response.status;
                    throw error;
                }
                if (response.status === 204) { // No Content success status
                    return null;
                }
                return response.json(); // Assuming all other successful responses are JSON
            } catch (error) {
                // Log the error and show a generic message to the user
                console.error(`API Error (${error.status || 'Network Error'}): ${error.message} for URL ${url}`, error.data || error);
                showMessage(`Error: ${error.message}. Check console for details.`, 'error');
                throw error; // Re-throw to allow specific error handling by the caller if needed
            }
        }


        // --- Initialization ---
        async function initializeApp() {
            try {
                showMessage('Loading initial data from API...', 'info');

                // Fetch all players
                const playersData = await fetchAPI('/api/players');
                allPlayers = playersData.reduce((acc, player) => {
                    acc[player.id] = player; // Player object includes id, name, name_lower, skill
                    return acc;
                }, {});

                // Fetch all outings
                const outingsData = await fetchAPI('/api/outings');
                const outingDetailsPromises = outingsData.map(async (outingBasic) => {
                    try {
                        // For each outing, fetch its players and its groups
                        const [outingPlayersData, outingGroupsData] = await Promise.all([
                            fetchAPI(`/api/outings/${outingBasic.id}/players`),
                            fetchAPI(`/api/outings/${outingBasic.id}/groups`) // This API returns { outingName, numberOfGroups, groups }
                        ]);
                        // Combine basic outing data with fetched players and groups
                        return {
                            ...outingBasic, // id, name, number_of_groups
                            playerIds: outingPlayersData.map(p => p.id), // Store only player IDs
                            groups: outingGroupsData.groups || [],       // Use the groups array from the response
                        };
                    } catch (e) {
                         console.warn(`Failed to load full details for outing ${outingBasic.name} (${outingBasic.id}): ${e.message}. Displaying with limited info.`);
                         // Return the basic outing info so it still appears in the list, but with empty players/groups
                         return {
                            ...outingBasic,
                            playerIds: [],
                            groups: [],
                            errorLoadingDetails: true // Flag that details are missing
                         };
                    }
                });

                const outingsWithDetails = await Promise.all(outingDetailsPromises);
                outings = outingsWithDetails.reduce((acc, outingWithDetails) => {
                    acc[outingWithDetails.id] = outingWithDetails;
                    return acc;
                }, {});

                clearMessage(); // Clear "Loading..." message
            } catch (error) {
                // If any of the initial fetches fail catastrophically (e.g., API down)
                showMessage(`Failed to initialize application: ${error.message}. Some data may be missing or app may not function correctly. Please try refreshing.`, 'error');
                // Application can still proceed with setupEventListeners and renderTabs,
                // but views might be empty or show errors.
            }

            setupEventListeners(); // Setup event listeners once after initial data load attempt
            renderTabs();          // Render available tabs

            // Determine initial view
            if (Object.keys(outings).length > 0) {
                // Sort outings by name to ensure consistent "first" outing if multiple exist
                const firstOutingId = Object.values(outings)
                                      .sort((a, b) => a.name.localeCompare(b.name))[0]?.id;
                if (firstOutingId) {
                    setActiveView(firstOutingId);
                } else { // Should ideally not happen if Object.keys(outings).length > 0
                    setActiveView(PLAYER_MGMT_VIEW_ID);
                }
            } else {
                // If no outings, default to player management view
                setActiveView(PLAYER_MGMT_VIEW_ID);
            }
        }

        // --- Data Persistence (REMOVED) ---
        // function saveData() { ... }
        // function loadData() { ... }

        // --- View Management ---
        function setActiveView(id) { // id can be an outingId or PLAYER_MGMT_VIEW_ID
            clearMessage();
            playerSearchInput.value = ''; // Reset search input
            hideSearchResults();
            hideAddNewPlayerSection();
            closeEditModal(); // Ensure edit modal is closed on view change

            if (id === PLAYER_MGMT_VIEW_ID) {
                currentViewMode = 'playerManagement';
                activeOutingId = null; // Clear active outing when switching to player management
                outingViewDiv.classList.add('hidden');
                playerManagementViewDiv.classList.remove('hidden');
                renderPlayerManagementView();
            } else if (outings[id]) { // id is an outingId (UUID)
                currentViewMode = 'outing';
                activeOutingId = id;
                outingViewDiv.classList.remove('hidden');
                playerManagementViewDiv.classList.add('hidden');
                updateOutingViewUI(); // This will render the specific outing's details
            } else {
                // This case might happen if an outing was deleted and was the active one
                console.warn("Invalid view/outing ID:", id, "Falling back to player management or first available outing.");
                // Fallback to the first available outing, or player management if no outings exist
                const availableOutingIds = Object.keys(outings);
                if (availableOutingIds.length > 0) {
                    // Sort by name to be consistent
                    setActiveView(Object.values(outings).sort((a,b) => a.name.localeCompare(b.name))[0].id);
                } else {
                    setActiveView(PLAYER_MGMT_VIEW_ID);
                }
                return; // Exit to avoid issues with highlightActiveTab if id is invalid
            }
            highlightActiveTab(id);
        }

        // --- Tab Management ---
        function highlightActiveTab(activeId) { // activeId can be PLAYER_MGMT_VIEW_ID or an outingId
            // Reset all tabs first
            tabsContainer.querySelectorAll('.tab, .outing-tab').forEach(tab => {
                tab.classList.remove('active', 'border-blue-500', 'text-blue-600', 'border-green-500', 'text-green-600');
                 // Reset general active styles if any were missed by specific color removals
                tab.classList.remove('font-semibold');
                if (!tab.id?.includes('tab-manage-players-btn')) { // Don't remove base text color from non-player tab
                    tab.classList.add('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                }
            });
             managePlayersTabBtn.classList.remove('active', 'border-green-500', 'text-green-600', 'font-semibold');
             managePlayersTabBtn.classList.add('text-gray-500'); // Ensure it has its base styling

            if (activeId === PLAYER_MGMT_VIEW_ID) {
                managePlayersTabBtn.classList.add('active', 'border-green-500', 'text-green-600', 'font-semibold');
                managePlayersTabBtn.classList.remove('text-gray-500');
            } else { // It's an outingId
                const activeTabButton = tabsContainer.querySelector(`.outing-tab[data-outing-id="${activeId}"]`);
                if (activeTabButton) {
                    activeTabButton.classList.add('active', 'border-blue-500', 'text-blue-600', 'font-semibold');
                    activeTabButton.classList.remove('text-gray-500', 'hover:text-gray-700', 'hover:border-gray-300');
                }
            }
        }


        function renderTabs() {
            tabsContainer.querySelectorAll('.outing-tab').forEach(tab => tab.remove()); // Clear existing outing tabs
            // Sort outings by name for display
            Object.values(outings).sort((a, b) => a.name.localeCompare(b.name)).forEach(outing => {
                // outing object now contains id, name, number_of_groups, playerIds, groups
                const tabButton = document.createElement('button');
                // Apply base classes, active state will be handled by highlightActiveTab
                tabButton.className = 'outing-tab tab whitespace-nowrap py-3 px-3 border-b-2 border-transparent text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300 rounded-t-md flex-shrink-0 flex items-center';
                tabButton.dataset.outingId = outing.id; // Use outing.id (UUID)
                const nameSpan = document.createElement('span');
                nameSpan.textContent = outing.name;
                tabButton.appendChild(nameSpan);

                const editBtn = document.createElement('span');
                editBtn.className = 'icon-btn edit-icon ml-2';
                editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
                editBtn.title = `Edit ${outing.name}`;
                editBtn.onclick = (event) => { event.stopPropagation(); editOutingDetails(outing.id); }; // Pass outing.id
                tabButton.appendChild(editBtn);

                const deleteBtn = document.createElement('span');
                deleteBtn.className = 'icon-btn delete-icon';
                deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>`;
                deleteBtn.title = `Delete ${outing.name}`;
                deleteBtn.onclick = (event) => { event.stopPropagation(); if (confirm(`Delete outing "${outing.name}"? This cannot be undone.`)) { deleteOuting(outing.id); }}; // Pass outing.id
                tabButton.appendChild(deleteBtn);

                tabButton.addEventListener('click', () => setActiveView(outing.id)); // Use outing.id
                tabsContainer.insertBefore(tabButton, addOutingBtn); // Insert before the "+ Add Outing" button
            });
            // After rendering, re-apply active styles based on current view
             highlightActiveTab(currentViewMode === 'playerManagement' ? PLAYER_MGMT_VIEW_ID : activeOutingId);
        }


        async function createNewOuting() {
            const newOutingName = prompt("Enter name for the new outing:", `Outing ${Object.keys(outings).length + 1}`);
            if (!newOutingName || newOutingName.trim() === "") {
                showMessage("Outing name cannot be empty.", "info");
                return;
            }
            const defaultNumberOfGroups = 3; // Or prompt for this too

            try {
                const newOuting = await fetchAPI('/api/outings', {
                    method: 'POST',
                    body: JSON.stringify({ name: newOutingName.trim(), numberOfGroups: defaultNumberOfGroups })
                });
                // API returns the created outing object { id, name, number_of_groups }
                newOuting.playerIds = []; // Initialize playerIds for the new outing
                newOuting.groups = [];    // Initialize groups for the new outing
                outings[newOuting.id] = newOuting; // Add to local state using its new ID

                renderTabs(); // Re-render tabs to include the new outing
                setActiveView(newOuting.id); // Switch to the new outing's view
                showMessage(`Outing "${newOuting.name}" created successfully.`, "success");
            } catch (error) {
                // Error message is already shown by fetchAPI helper
                // console.error("Failed to create outing:", error); (already logged by fetchAPI)
            }
        }

        async function editOutingDetails(outingId) { // Changed from editOutingName to editOutingDetails
             const outing = outings[outingId];
             if (!outing) {
                 showMessage("Outing not found for editing.", "error");
                 return;
             }

             const newName = prompt(`Enter new name for outing "${outing.name}" (current: ${outing.name}):`, outing.name);
             const newNumGroupsStr = prompt(`Enter new number of groups for "${outing.name}" (current: ${outing.numberOfGroups}):`, outing.numberOfGroups);

             const updatePayload = {};
             let changed = false;

             if (newName !== null && newName.trim() !== "" && newName.trim() !== outing.name) {
                 updatePayload.name = newName.trim();
                 changed = true;
             }
             if (newNumGroupsStr !== null && newNumGroupsStr.trim() !== "") {
                 const numGroups = parseInt(newNumGroupsStr, 10);
                 if (!isNaN(numGroups) && numGroups > 0 && numGroups !== outing.numberOfGroups) {
                     updatePayload.numberOfGroups = numGroups;
                     changed = true;
                 } else if (isNaN(numGroups) || numGroups <=0) { // Added check for invalid number
                     showMessage("Invalid number of groups. Must be a positive integer.", "error");
                     return; // Don't proceed if number of groups is invalid
                 }
             }

             if (changed) {
                 try {
                     const updatedOutingFromAPI = await fetchAPI(`/api/outings/${outingId}`, {
                         method: 'PUT',
                         body: JSON.stringify(updatePayload)
                     });
                     // API returns the full updated outing object { id, name, number_of_groups }
                     // Update local state, preserving playerIds and groups which are not part of this update
                     outings[outingId] = {
                        ...outings[outingId], // keep existing playerIds, groups
                        name: updatedOutingFromAPI.name,
                        number_of_groups: updatedOutingFromAPI.number_of_groups
                     };

                     renderTabs(); // Re-render tabs in case name changed
                     if (activeOutingId === outingId) { // If current view is this outing
                         updateOutingViewUI(); // Re-render the main view for this outing
                     }
                     showMessage(`Outing "${outings[outingId].name}" updated successfully.`, "success");
                 } catch (error) {
                    // Error message handled by fetchAPI
                    // console.error("Failed to update outing:", error); (already logged)
                 }
             } else {
                 showMessage("No changes made to the outing.", "info");
             }
         }

        async function deleteOuting(outingIdToDelete) {
            if (!outings[outingIdToDelete]) {
                 showMessage("Outing not found for deletion.", "error");
                 return;
            }
            try {
                await fetchAPI(`/api/outings/${outingIdToDelete}`, { method: 'DELETE' }); // API call to delete
                const deletedOutingName = outings[outingIdToDelete].name; // Get name for message before deleting from local
                delete outings[outingIdToDelete]; // Remove from local state

                if (activeOutingId === outingIdToDelete) { // If the deleted outing was active
                    const remainingOutingIds = Object.keys(outings);
                    if (remainingOutingIds.length > 0) {
                        // setActiveView to the first available outing (sorted by name for consistency)
                        setActiveView(Object.values(outings).sort((a,b) => a.name.localeCompare(b.name))[0].id);
                    } else {
                        setActiveView(PLAYER_MGMT_VIEW_ID); // If no outings left, go to player management
                    }
                }
                renderTabs(); // Re-render tabs to remove the deleted one
                showMessage(`Outing "${deletedOutingName}" deleted successfully.`, "success");
            } catch (error) {
                // Error message handled by fetchAPI
                // console.error("Failed to delete outing:", error); (already logged)
            }
        }

        // --- Player Search and Add (Outing View) ---
        function handlePlayerSearch() {
            const searchTerm = playerSearchInput.value.trim().toLowerCase();
            searchResultsDiv.innerHTML = ''; // Clear previous results
            hideAddNewPlayerSection();

            if (!searchTerm) { hideSearchResults(); return; }

            // Search from the local `allPlayers` cache (which is populated from API on init)
            // Player objects in `allPlayers` include `id`, `name`, `name_lower`, `skill`
            const matchingPlayers = Object.values(allPlayers)
                .filter(player => player.name_lower.includes(searchTerm))
                .sort((a, b) => a.name.localeCompare(b.name)); // Sort by proper name

            if (matchingPlayers.length > 0) {
                matchingPlayers.forEach(player => {
                    const item = document.createElement('div');
                    item.classList.add('search-result-item');
                    item.textContent = `${player.name} (Skill: ${player.skill})`;
                    item.addEventListener('click', () => selectPlayerFromSearch(player.id)); // Pass player ID
                    searchResultsDiv.appendChild(item);
                });
                showSearchResults();
            } else {
                // If no existing players match, show option to add new player
                showAddNewPlayerSection(playerSearchInput.value.trim());
                hideSearchResults();
            }
        }

        async function selectPlayerFromSearch(playerId) { // Accepts playerId (UUID)
            // This function is called when a player is clicked from search results.
            // It should add the selected player to the current outing.
            await addPlayerToCurrentOuting(playerId); // Changed to accept ID and be async
            playerSearchInput.value = ''; // Clear search input
            hideSearchResults();
            hideAddNewPlayerSection();
            playerSearchInput.focus(); // Return focus to search input
        }

         function showAddNewPlayerSection(nameAttempt) { // nameAttempt is the string from search input
             if (!nameAttempt) return;
             newPlayerNameDisplay.textContent = nameAttempt; // Display the name they tried to search for
             newPlayerSkillSlider.value = 5; // Default skill
             newSkillValueSpan.textContent = '5';
             addNewPlayerSection.classList.remove('hidden');
        }

        async function addNewPlayerFromOutingView() {
            // This is called when "Add New Player to Database" is clicked from outing view
            const newName = newPlayerNameDisplay.textContent; // Name is pre-filled from search attempt
            const skill = parseInt(newPlayerSkillSlider.value, 10);

            try {
                // addPlayerToDatabase now handles API call and updates `allPlayers`
                const newPlayer = await addPlayerToDatabase(newName, skill);
                if (newPlayer) { // If player was successfully added to database
                    await addPlayerToCurrentOuting(newPlayer.id); // Add the new player (by ID) to current outing
                    playerSearchInput.value = ''; // Clear search input
                    hideAddNewPlayerSection();
                    playerSearchInput.focus();
                }
            } catch (error) {
                // Error messages are handled by addPlayerToDatabase or addPlayerToCurrentOuting via fetchAPI
                // console.error("Error adding new player from outing view:", error);
            }
        }


        // --- Outing Player Management ---
         async function addPlayerToCurrentOuting(playerId) { // Accepts playerId (UUID)
             if (currentViewMode !== 'outing' || !activeOutingId || !outings[activeOutingId]) {
                 showMessage("Please select an active outing first.", "error"); return;
             }
             const currentOuting = outings[activeOutingId];
             const player = allPlayers[playerId]; // Get player object from `allPlayers` using ID

             if (!player) { showMessage(`Player with ID "${playerId}" not found in local cache. Try refreshing.`, "error"); return; }

             // Check if player is already in the outing (using playerIds array)
             if (currentOuting.playerIds && !currentOuting.playerIds.includes(playerId)) {
                 try {
                     // API call to add player to outing
                     await fetchAPI(`/api/outings/${activeOutingId}/players`, {
                         method: 'POST',
                         body: JSON.stringify({ playerId: playerId }) // API expects { "playerId": "uuid" }
                     });
                     currentOuting.playerIds.push(playerId); // Update local state

                     // After adding a player, the groups might change, so re-fetch them.
                     await refreshOutingGroups(activeOutingId);
                     updateOutingPlayerList(); // Update the displayed list of players in the outing
                     // updateOutingViewUI(); // This will also call displayGroups with the new groups.

                     showMessage(`${player.name} added to ${currentOuting.name}.`, 'success');
                 } catch (error) {
                     // Error message handled by fetchAPI
                     // console.error(`Failed to add player ${player.name} to outing:`, error);
                 }
             } else if (currentOuting.playerIds && currentOuting.playerIds.includes(playerId)) {
                 showMessage(`"${player.name}" is already in this outing.`, 'info');
             } else { // Should not happen if playerIds is initialized
                 currentOuting.playerIds = [playerId]; // Initialize if it was undefined/null
                 // proceed with API call as above... (this part is a bit redundant if playerIds is always an array)
                 // For robustness, could combine with the above block or ensure playerIds is always array.
                 console.warn("currentOuting.playerIds was not initialized properly. Initializing now.");
                 // Repeat API call logic here or refactor to avoid repetition
                  try {
                     await fetchAPI(`/api/outings/${activeOutingId}/players`, {
                         method: 'POST',
                         body: JSON.stringify({ playerId: playerId })
                     });
                     await refreshOutingGroups(activeOutingId);
                     updateOutingPlayerList();
                     showMessage(`${player.name} added to ${currentOuting.name}.`, 'success');
                 } catch (error) { /* Handled by fetchAPI */ }
             }
         }

        async function removePlayerFromOuting(playerId) { // Accepts playerId (UUID)
             if (currentViewMode !== 'outing' || !activeOutingId || !outings[activeOutingId]) return;
             const currentOuting = outings[activeOutingId];
             const player = allPlayers[playerId]; // Get player object for the name in message

             if (!player) { showMessage("Player not found in local cache. Cannot remove.", "error"); return; }

             if (confirm(`Remove ${player.name} from outing ${currentOuting.name}?`)) {
                 try {
                     // API call to remove player from outing
                     await fetchAPI(`/api/outings/${activeOutingId}/players/${playerId}`, { method: 'DELETE' });
                     // Update local state: remove player ID from playerIds array
                     currentOuting.playerIds = currentOuting.playerIds.filter(id => id !== playerId);

                     // After removing a player, groups will change, so re-fetch them.
                     await refreshOutingGroups(activeOutingId);
                     updateOutingPlayerList(); // Update UI list of players
                     // updateOutingViewUI(); // This will also call displayGroups.

                     showMessage(`${player.name} removed from ${currentOuting.name}.`, 'success');
                 } catch (error) {
                     // Error message handled by fetchAPI
                     // console.error(`Failed to remove player ${player.name} from outing:`, error);
                 }
            }
        }

        function updateOutingPlayerList() {
            outingPlayerListDiv.innerHTML = ''; // Clear existing list
            if (currentViewMode !== 'outing' || !activeOutingId || !outings[activeOutingId]) return;

            const currentOuting = outings[activeOutingId];
            // Ensure playerIds array exists
            const playerIdsToShow = currentOuting.playerIds || [];

            if (playerIdsToShow.length === 0) {
                outingPlayerListDiv.innerHTML = '<p class="text-sm text-gray-500 italic">No players added to this outing yet.</p>';
                return;
            }

            // Map IDs to full player objects from `allPlayers` and sort them
            const playersInOuting = playerIdsToShow
                .map(playerId => allPlayers[playerId]) // Get player object from allPlayers using ID
                .filter(player => player) // Filter out any undefined if an ID mismatch somehow occurs
                .sort((a, b) => a.name.localeCompare(b.name)); // Sort by proper name for display

            playersInOuting.forEach(player => { // player is now {id, name, name_lower, skill}
                const playerElement = document.createElement('div');
                playerElement.className = 'player-item flex justify-between items-center text-sm p-1.5 rounded';

                const nameSkillContainer = document.createElement('div');
                nameSkillContainer.className = 'flex items-center';
                const nameSpan = document.createElement('span');
                nameSpan.textContent = `${player.name} (Skill: ${player.skill})`;
                nameSkillContainer.appendChild(nameSpan);

                const barContainer = document.createElement('div');
                barContainer.className = 'inline-skill-bar-container tooltip-container';
                const bar = document.createElement('div'); bar.className = 'inline-skill-bar';
                bar.style.width = `${(player.skill / 10) * 100}%`;
                barContainer.appendChild(bar);
                const tooltip = document.createElement('span'); tooltip.className = 'tooltiptext';
                tooltip.textContent = `Skill: ${player.skill}/10`;
                barContainer.appendChild(tooltip);
                nameSkillContainer.appendChild(barContainer);
                playerElement.appendChild(nameSkillContainer);

                const removeBtn = document.createElement('button');
                removeBtn.className = 'icon-btn delete-icon flex-shrink-0';
                removeBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18 18 6M6 6l12 12" /></svg>`;
                removeBtn.title = `Remove ${player.name}`;
                removeBtn.onclick = () => removePlayerFromOuting(player.id); // Pass player.id
                playerElement.appendChild(removeBtn);
                outingPlayerListDiv.appendChild(playerElement);
            });
        }

        // --- Player Database Management ---
        async function addPlayerToDatabase(name, skill) { // Removed calledFromOutingView param, not needed
            const trimmedName = name.trim();
            if (!trimmedName) { showMessage("Player name cannot be empty.", "error"); return null; } // Return null on failure
            if (isNaN(skill) || skill < 1 || skill > 10) { // Ensure skill is a number
                 showMessage("Skill must be a number between 1 and 10.", "error"); return null;
            }

            // Optional: Client-side check for existing name (API will be the source of truth for uniqueness)
            const nameLower = trimmedName.toLowerCase();
            if (Object.values(allPlayers).some(p => p.name_lower === nameLower)) {
                showMessage(`Player with name "${trimmedName}" already exists (client-side check). API will confirm.`, "warning");
                // Allow to proceed, API will handle conflict if it's truly a duplicate by its rules.
            }

            try {
                const newPlayer = await fetchAPI('/api/players', {
                    method: 'POST',
                    body: JSON.stringify({ name: trimmedName, skill: parseInt(skill, 10) })
                });
                // API returns the created player object { id, name, name_lower, skill }
                allPlayers[newPlayer.id] = newPlayer; // Add to local cache by ID

                showMessage(`Player "${newPlayer.name}" added to database.`, "success");
                if (currentViewMode === 'playerManagement') {
                    renderPlayerManagementView(); // Refresh the list in player management view
                    mgmtPlayerNameInput.value = ''; // Reset form
                    mgmtPlayerSkillSlider.value = 5;
                    mgmtSkillValueSpan.textContent = '5';
                }
                return newPlayer; // Return the created player object for immediate use (e.g., adding to outing)
            } catch (error) {
                // Error message is already handled by fetchAPI helper.
                // console.error("Failed to add player to database:", error); (already logged)
                return null; // Indicate failure
            }
        }

        function renderPlayerManagementView() {
            allPlayersListDiv.innerHTML = ''; // Clear existing list
            // Reset add player form in this view
            mgmtPlayerNameInput.value = '';
            mgmtPlayerSkillSlider.value = 5;
            mgmtSkillValueSpan.textContent = '5';

            // Get players from local cache, sort by lowercase name for display
            const sortedPlayers = Object.values(allPlayers).sort((a, b) => a.name_lower.localeCompare(b.name_lower));

            if (sortedPlayers.length === 0) {
                allPlayersListDiv.innerHTML = '<p class="text-sm text-gray-500 italic">No players in the database yet. Add some!</p>';
                return;
            }
            sortedPlayers.forEach(player => { // player is {id, name, name_lower, skill}
                const itemDiv = document.createElement('div'); itemDiv.className = 'mgmt-player-item';
                const infoSpan = document.createElement('span');
                infoSpan.textContent = `${player.name} (Skill: ${player.skill})`;
                itemDiv.appendChild(infoSpan);

                const actionsDiv = document.createElement('div'); actionsDiv.className = 'flex items-center space-x-2 flex-shrink-0';
                const editBtn = document.createElement('button'); editBtn.className = 'icon-btn edit-icon'; editBtn.title = `Edit ${player.name}`;
                editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg>`;
                editBtn.onclick = () => openEditModal(player.id); // Pass player ID to modal
                actionsDiv.appendChild(editBtn);

                const deleteBtn = document.createElement('button'); deleteBtn.className = 'icon-btn delete-icon'; deleteBtn.title = `Delete ${player.name}`;
                deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg>`;
                deleteBtn.onclick = () => deletePlayerFromDatabase(player.id); // Pass player ID
                actionsDiv.appendChild(deleteBtn);
                itemDiv.appendChild(actionsDiv);
                allPlayersListDiv.appendChild(itemDiv);
            });
        }

        async function handleAddPlayerFromMgmt() {
            const name = mgmtPlayerNameInput.value;
            const skill = parseInt(mgmtPlayerSkillSlider.value, 10);
            // addPlayerToDatabase handles API call, local state update, success/error messages, and form reset.
            await addPlayerToDatabase(name, skill);
        }


        // --- Edit Player Modal Logic ---
        function openEditModal(playerId) { // Accepts playerId (UUID)
            const player = allPlayers[playerId]; // Get player from local cache by ID
            if (!player) {
                showMessage("Player not found for editing. Try refreshing.", "error");
                return;
            }
            // Store player ID in a hidden input to know which player to update on save
            editPlayerOriginalNameInput.value = player.id; // Using this hidden input to store ID
            editPlayerNameInput.value = player.name; // Populate form with current name
            editPlayerSkillSlider.value = player.skill; // Populate form with current skill
            editSkillValueSpan.textContent = player.skill; // Update skill display
            editPlayerModal.classList.add('visible'); // Show the modal
        }

        function closeEditModal() {
            editPlayerModal.classList.remove('visible');
        }

        async function handleSaveEditPlayer() {
            const playerId = editPlayerOriginalNameInput.value; // This hidden input now stores the player's ID
            const playerToUpdate = allPlayers[playerId];

            if (!playerToUpdate) {
                showMessage("Original player not found for update! This is unexpected. Try refreshing.", "error");
                closeEditModal();
                return;
            }

            const newName = editPlayerNameInput.value.trim();
            const newSkill = parseInt(editPlayerSkillSlider.value, 10);

            if (!newName) { showMessage("Player name cannot be empty.", "error"); return; }
            if (isNaN(newSkill) || newSkill < 1 || newSkill > 10) {
                showMessage("Skill must be a number between 1 and 10.", "error"); return;
            }

            // Determine what actually changed
            const updatePayload = {};
            if (newName !== playerToUpdate.name) {
                updatePayload.name = newName;
            }
            if (newSkill !== playerToUpdate.skill) {
                updatePayload.skill = newSkill;
            }

            if (Object.keys(updatePayload).length === 0) {
                showMessage("No changes detected.", "info");
                closeEditModal();
                return;
            }

            // Optimistic: Client-side check for name uniqueness if name changed
            // API will be the final arbiter of uniqueness for name_lower.
            if (updatePayload.name && Object.values(allPlayers).some(p => p.id !== playerId && p.name_lower === newName.toLowerCase())) {
                showMessage(`Another player with name "${newName}" already exists (client-side check).`, 'error');
                return; // Prevent API call if client-side check fails for user experience
            }

            try {
                const updatedPlayerFromAPI = await fetchAPI(`/api/players/${playerId}`, {
                    method: 'PUT',
                    body: JSON.stringify(updatePayload)
                });
                // API returns the full updated player object { id, name, name_lower, skill }
                allPlayers[playerId] = updatedPlayerFromAPI; // Update local cache with response from API

                showMessage(`Player "${updatedPlayerFromAPI.name}" updated successfully.`, "success");
                closeEditModal();
                renderPlayerManagementView(); // Refresh the list in player management view

                // If the updated player is in the currently active outing, refresh that view too
                if (currentViewMode === 'outing' && activeOutingId && outings[activeOutingId]?.playerIds.includes(playerId)) {
                     updateOutingViewUI(); // This will re-render player list and potentially groups
                }
            } catch (error) {
                // Error message already handled by fetchAPI.
                // If it was a 409 conflict due to name_lower, the message from API is shown.
                // console.error("Failed to save player edits:", error); (already logged)
            }
        }


        async function deletePlayerFromDatabase(playerId) { // Accepts playerId (UUID)
            const player = allPlayers[playerId]; // Get player from local cache
            if (!player) {
                showMessage("Player not found for deletion. Try refreshing.", "error");
                return;
            }

            if (confirm(`⚠️ DELETE "${player.name}" from database?\n\nThis will remove the player from all outings as well (due to database CASCADE DELETE settings). This action cannot be undone.`)) {
                try {
                    await fetchAPI(`/api/players/${playerId}`, { method: 'DELETE' }); // API call to delete
                    const deletedPlayerName = player.name; // Store name for message before deleting from local cache
                    delete allPlayers[playerId]; // Remove from local cache

                    // Update all outings in local state: remove this player ID from their playerIds arrays
                    // and clear groups if the player was in an active outing, as groups will change.
                    Object.values(outings).forEach(outing => {
                        if (outing.playerIds) {
                            const playerIndex = outing.playerIds.indexOf(playerId);
                            if (playerIndex > -1) {
                                outing.playerIds.splice(playerIndex, 1);
                                // If this player was in the currently active outing, its groups are now invalid.
                                // They will be re-fetched by updateOutingViewUI or refreshOutingGroups.
                                if (outing.id === activeOutingId) {
                                    outing.groups = []; // Clear local groups cache for this outing
                                }
                            }
                        }
                    });

                    showMessage(`Player "${deletedPlayerName}" deleted successfully.`, "success");

                    if (currentViewMode === 'playerManagement') {
                        renderPlayerManagementView(); // Refresh player list
                    } else if (currentViewMode === 'outing' && activeOutingId) {
                        // If in an outing view, refresh it. The deleted player will be gone.
                        // Groups will need to be re-fetched.
                        await refreshOutingGroups(activeOutingId); // Explicitly re-fetch groups for the current outing
                        updateOutingViewUI(); // Then update the whole UI for the outing
                    }
                } catch (error) {
                    // Error message handled by fetchAPI
                    // console.error("Failed to delete player:", error); (already logged)
                }
            }
        }


        // --- Group Generation & Display ---
        // generateGroups function is removed. Group generation is now handled by the API.
        // The client will call handleGenerateGroups which calls the API.

        async function handleGenerateGroups(useShuffle = false) { // Renamed from generateAndDisplayGroups
            clearMessage();
            if (currentViewMode !== 'outing' || !activeOutingId || !outings[activeOutingId]) {
                showMessage("No active outing selected to generate groups for.", "error");
                return;
            }
            const currentOuting = outings[activeOutingId];
            if (!currentOuting.playerIds || currentOuting.playerIds.length === 0) {
                showMessage("No players in this outing to generate groups.", "info");
                currentOuting.groups = []; // Clear any existing groups
                displayGroups(currentOuting.groups); // Update display to show empty
                return;
            }

            const shuffleQueryParam = useShuffle ? '?shuffle=true' : '';
            try {
                // API endpoint /api/outings/:outingId/groups handles group generation
                const groupDataFromAPI = await fetchAPI(`/api/outings/${activeOutingId}/groups${shuffleQueryParam}`);
                // API returns { outingName, numberOfGroups (optional), groups: [...] }
                // We primarily care about the 'groups' array.
                currentOuting.groups = groupDataFromAPI.groups || []; // Update local outing object with new groups
                // Optionally, update outing name or numberOfGroups if API can change them, though unlikely for this endpoint.
                // currentOuting.name = groupDataFromAPI.outingName || currentOuting.name;
                // currentOuting.numberOfGroups = groupDataFromAPI.numberOfGroups || currentOuting.numberOfGroups;

                displayGroups(currentOuting.groups); // Update the UI with the new groups
                showMessage("Groups generated successfully from API!", "success");
            } catch (error) {
                // Error message handled by fetchAPI
                // console.error("Failed to generate groups from API:", error); (already logged)
                currentOuting.groups = []; // Clear groups on error
                displayGroups(currentOuting.groups); // Update display to show empty state
            }
        }

        // Helper to specifically re-fetch groups for an outing, e.g., after player add/remove or num_groups change
        async function refreshOutingGroups(outingIdToRefresh) {
            if (!outings[outingIdToRefresh]) {
                console.warn("Cannot refresh groups for non-existent outing ID:", outingIdToRefresh);
                return;
            }
            try {
                const groupData = await fetchAPI(`/api/outings/${outingIdToRefresh}/groups`); // Default no shuffle for refresh
                outings[outingIdToRefresh].groups = groupData.groups || [];
            } catch (error) {
                console.warn(`Could not refresh groups for outing ${outingIdToRefresh}: ${error.message}`);
                outings[outingIdToRefresh].groups = []; // Clear local groups on error to avoid stale data
            }
        }


        function displayGroups(groupsToDisplay) { // Parameter renamed for clarity, accepts array of group objects
            groupDisplayDiv.innerHTML = ''; // Clear previous group display

            const currentOutingForDisplay = activeOutingId ? outings[activeOutingId] : null;

            if (!groupsToDisplay || groupsToDisplay.length === 0) {
                 if (currentOutingForDisplay && currentOutingForDisplay.playerIds && currentOutingForDisplay.playerIds.length > 0) {
                     groupDisplayDiv.innerHTML = '<p class="text-gray-500 italic sm:col-span-2 lg:col-span-3">Groups have not been generated or are empty. Click "Recalculate Groups".</p>';
                 } else if (currentOutingForDisplay) { // Has an active outing, but no players
                      groupDisplayDiv.innerHTML = '<p class="text-gray-500 italic sm:col-span-2 lg:col-span-3">Add players to this outing first, then generate groups.</p>';
                 } else { // No active outing (e.g. player management view)
                     // This part of UI is hidden in player management, but good to be safe.
                     groupDisplayDiv.innerHTML = '<p class="text-gray-500 italic sm:col-span-2 lg:col-span-3">No outing selected or no groups to display.</p>';
                 }
                return;
            }

            // Determine max total skill for scaling bars, using the current groups to display
            // This ensures bars are scaled relative to the current set of groups.
            let maxTotalSkill = 0;
            groupsToDisplay.forEach(group => {
                if (group.totalSkill > maxTotalSkill) maxTotalSkill = group.totalSkill;
            });
            const scaleMax = Math.max(maxTotalSkill, 10); // Ensure scale isn't zero, min scale of 10 for very low skills

            // Groups from API now have { name (fun name), players: [{id, name, skill}], totalSkill }
            groupsToDisplay.sort((a, b) => a.name.localeCompare(b.name)).forEach(group => { // Sort groups by fun name
                const groupCard = document.createElement('div');
                groupCard.className = 'group-card bg-white p-4 rounded-lg border border-gray-200 shadow-sm flex flex-col';

                const avgSkill = group.players.length > 0 ? (group.totalSkill / group.players.length).toFixed(1) : 'N/A';

                // Players array within each group object from API: [{id, name, skill}]
                let playerListHTML = group.players.map(p => `<li class="text-sm text-gray-600">${p.name} (Skill: ${p.skill})</li>`).join('');
                if (!playerListHTML) playerListHTML = '<li class="text-sm text-gray-400 italic">Empty Group</li>';

                const infoDiv = document.createElement('div');
                infoDiv.innerHTML = `
                    <h3 class="text-md font-semibold text-blue-700 mb-1">${group.name}</h3>
                    <p class="text-sm text-gray-500 mb-2">Avg Skill: ${avgSkill} | Total: ${group.totalSkill}</p>
                    <ul class="space-y-1 list-disc list-inside mb-3">${playerListHTML}</ul>`;
                groupCard.appendChild(infoDiv);

                // Skill bar visualization
                const skillBarDiv = document.createElement('div'); skillBarDiv.className = 'mt-auto'; // Push to bottom
                const barContainer = document.createElement('div'); barContainer.className = 'group-skill-bar-container tooltip-container';
                const bar = document.createElement('div'); bar.className = 'group-skill-bar';
                const barWidth = scaleMax > 0 ? (group.totalSkill / scaleMax) * 100 : 0;
                bar.style.width = `${Math.min(barWidth, 100)}%`; // Cap at 100%
                // bar.textContent = group.totalSkill; // Optionally display skill value on the bar
                barContainer.appendChild(bar);
                const tooltip = document.createElement('span'); tooltip.className = 'tooltiptext';
                tooltip.textContent = `Total Skill: ${group.totalSkill}`;
                barContainer.appendChild(tooltip);
                skillBarDiv.appendChild(barContainer);
                groupCard.appendChild(skillBarDiv);

                groupDisplayDiv.appendChild(groupCard);
            });
        }


        // --- UI Update Trigger ---
        async function updateOutingViewUI() { // Made async because it might call refreshOutingGroups
             if (currentViewMode !== 'outing' || !activeOutingId || !outings[activeOutingId]) return;
             const currentOuting = outings[activeOutingId];

             updateOutingPlayerList(); // Renders player list based on currentOuting.playerIds and allPlayers

             // Update Number of Groups input
             numGroupsInput.value = currentOuting.numberOfGroups;
             // Max groups should not exceed number of players, but can't be less than 1
             const maxPlayerBasedGroups = currentOuting.playerIds ? currentOuting.playerIds.length : 1;
             numGroupsInput.max = Math.max(1, maxPlayerBasedGroups); // Ensure max is at least 1

             // If current numGroupsInput value exceeds new max (e.g. after removing players), adjust it.
             if (parseInt(numGroupsInput.value) > parseInt(numGroupsInput.max)) {
                numGroupsInput.value = numGroupsInput.max;
                // If this adjustment changes the outing's number_of_groups, we should update the backend.
                if (currentOuting.numberOfGroups !== parseInt(numGroupsInput.value)) {
                    currentOuting.numberOfGroups = parseInt(numGroupsInput.value);
                    try {
                        await fetchAPI(`/api/outings/${activeOutingId}`, {
                            method: 'PUT',
                            body: JSON.stringify({ numberOfGroups: currentOuting.numberOfGroups })
                        });
                        // After updating numberOfGroups, groups are likely invalid, so refresh them.
                        await refreshOutingGroups(activeOutingId);
                    } catch (error) {
                        showMessage("Failed to update number of groups on the server. UI may be inconsistent.", "error");
                        // Potentially revert local change or re-fetch all data if critical
                    }
                }
             }
             // Always display groups based on current local state (which should be fresh if changes occurred)
             displayGroups(currentOuting.groups);
        }

        // --- Utility Functions ---
        function showMessage(message, type = 'info') { // type can be 'info', 'error', 'success', 'warning'
             messageArea.textContent = message;
             let colorClass = 'text-blue-600'; // Default for info
             if (type === 'error') colorClass = 'text-red-600';
             else if (type === 'success') colorClass = 'text-green-600';
             else if (type === 'warning') colorClass = 'text-yellow-600'; // Added warning color

             messageArea.className = `mt-6 text-center font-medium ${colorClass}`;
             // For non-error messages, clear after a delay
             if (type !== 'error') {
                 setTimeout(() => {
                    // Only clear if the message hasn't changed in the meantime
                    if (messageArea.textContent === message) {
                        clearMessage();
                    }
                 }, 3500);
             }
        }
        function clearMessage() { messageArea.textContent = ''; messageArea.className = 'mt-6 text-center font-medium'; }
        function showMessageV3(message, type = 'info'){ // Replicated V3/V4
             messageArea.textContent = message;
             messageArea.className = `mt-6 text-center font-medium ${ type === 'error' ? 'text-red-600' : type === 'success' ? 'text-green-600' : 'text-blue-600' }`;
             if (type !== 'error') { setTimeout(clearMessage, 3500); }
        }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Tab Switching
            managePlayersTabBtn.addEventListener('click', () => setActiveView(PLAYER_MGMT_VIEW_ID));
            addOutingBtn.addEventListener('click', createNewOuting);

            // Outing View: Player Search & Add
            playerSearchInput.addEventListener('input', handlePlayerSearch);
            document.addEventListener('click', (event) => {
                if (!playerSearchInput.contains(event.target) && !searchResultsDiv.contains(event.target)) {
                    hideSearchResults(); if (!playerSearchInput.value.trim()) hideAddNewPlayerSection();
                }
            });
            newPlayerSkillSlider.addEventListener('input', () => { newSkillValueSpan.textContent = newPlayerSkillSlider.value; });
            addNewPlayerBtn.addEventListener('click', addNewPlayerFromOutingView);

            // Outing View: Group Config
            numGroupsInput.addEventListener('change', () => { // Use 'change' for number input
                 if (currentViewMode === 'outing' && activeOutingId && outings[activeOutingId]) {
                     let groupsVal = parseInt(numGroupsInput.value, 10);
                     const maxGroups = parseInt(numGroupsInput.max, 10) || 10; // Use max from attribute or default 10
                     // Re-validate on change
                     groupsVal = Math.max(1, Math.min(groupsVal, maxGroups));
                     numGroupsInput.value = groupsVal; // Update input if corrected

                     // Save the validated number to the outing state
                     outings[activeOutingId].numberOfGroups = groupsVal;
                     // Auto-generate groups on change (will also save state)
                     generateAndDisplayGroups(false); // No shuffle for auto-update
                 }
            });
            // Recalculate button uses randomness
            recalculateBtn.addEventListener('click', () => generateAndDisplayGroups(true));

            // Player Management View: Add Player
            mgmtPlayerSkillSlider.addEventListener('input', () => { mgmtSkillValueSpan.textContent = mgmtPlayerSkillSlider.value; });
            mgmtAddPlayerBtn.addEventListener('click', handleAddPlayerFromMgmt);
            mgmtPlayerNameInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') { handleAddPlayerFromMgmt(); } });

            // Edit Player Modal
            cancelEditPlayerBtn.addEventListener('click', closeEditModal);
            saveEditPlayerBtn.addEventListener('click', handleSaveEditPlayer);
            editPlayerSkillSlider.addEventListener('input', () => { editSkillValueSpan.textContent = editPlayerSkillSlider.value; });
             editPlayerModal.addEventListener('click', (event) => {
                 if (event.target === editPlayerModal) { closeEditModal(); }
             });
        }

        // Make functions globally accessible if needed for inline handlers
        window.removePlayerFromOuting = removePlayerFromOuting;
        window.openEditModal = openEditModal;
        window.deletePlayerFromDatabase = deletePlayerFromDatabase;
        window.editOutingName = editOutingName;

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>

</body>
</html>
