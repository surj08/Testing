<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golf Group Organizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif; /* Use Inter font */
        }
        /* Style for active tab */
        .tab.active {
            border-bottom-color: #3b82f6; /* Blue bottom border for active tab */
            font-weight: 600;
            color: #3b82f6;
        }
        /* Style for tab hover */
        .tab:not(.active):hover {
            border-bottom-color: #d1d5db; /* Gray bottom border on hover */
            color: #6b7280;
        }
        /* Ensure sliders look consistent */
        input[type=range] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* Gray track */
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 9999px; /* Rounded track */
        }
        input[type=range]:hover {
            opacity: 1;
        }
        /* Style slider thumb */
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #3b82f6; /* Blue thumb */
            cursor: pointer;
            border-radius: 50%; /* Circular thumb */
        }
        input[type=range]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #3b82f6; /* Blue thumb */
            cursor: pointer;
            border-radius: 50%; /* Circular thumb */
            border: none; /* Remove default border in Firefox */
        }
        /* Simple animation for group display */
        .group-card {
            transition: all 0.3s ease-in-out;
        }
        .player-item {
             transition: background-color 0.2s ease-in-out;
        }
         .player-item:hover {
             background-color: #f3f4f6; /* Light gray on hover */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-100 p-4 md:p-8">

    <div class="max-w-4xl mx-auto bg-white rounded-lg shadow-md p-6">
        <h1 class="text-2xl font-bold text-center text-gray-800 mb-6">Golf Group Organizer</h1>

        <div class="border-b border-gray-200 mb-6">
            <nav id="tabs" class="-mb-px flex space-x-4" aria-label="Tabs">
                <button id="add-outing-btn" class="whitespace-nowrap py-3 px-3 border-b-2 border-transparent text-sm font-medium text-gray-500 hover:text-gray-700 hover:border-gray-300 rounded-t-md">
                    + Add Outing
                </button>
            </nav>
        </div>

        <div id="tab-content">

            <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Manage Players</h2>
                <div class="flex flex-col md:flex-row md:items-end gap-4">
                    <div class="flex-grow">
                        <label for="player-name" class="block text-sm font-medium text-gray-700 mb-1">Player Name</label>
                        <input type="text" id="player-name" placeholder="Enter player name" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                    </div>
                    <div class="flex-grow md:max-w-xs">
                        <label for="player-skill" class="block text-sm font-medium text-gray-700 mb-1">Skill Level (<span id="skill-value">5</span>)</label>
                        <input type="range" id="player-skill" min="1" max="10" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <button id="add-player-btn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition duration-150 ease-in-out">
                        Add Player
                    </button>
                </div>
                 <div id="player-list" class="mt-4 max-h-48 overflow-y-auto space-y-1 pr-2">
                    </div>
            </div>

            <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Configure Groups</h2>
                 <div class="flex flex-col md:flex-row md:items-center gap-4">
                    <div class="flex-grow">
                         <label for="num-groups" class="block text-sm font-medium text-gray-700 mb-1">Number of Groups (<span id="groups-value">2</span>)</label>
                        <input type="range" id="num-groups" min="1" max="10" value="2" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <button id="shake-up-btn" class="mt-2 md:mt-0 px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition duration-150 ease-in-out">
                        Generate / Shake Up Groups
                    </button>
                 </div>
            </div>

            <div>
                <h2 class="text-lg font-semibold text-gray-700 mb-3">Generated Groups</h2>
                <div id="group-display" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <p class="text-gray-500 italic">Add players and configure the number of groups above, then click "Generate / Shake Up Groups".</p>
                </div>
                 <div id="message-area" class="mt-4 text-center text-red-600 font-medium"></div>
            </div>

        </div> </div> <script>
        // --- DOM Elements ---
        const tabsContainer = document.getElementById('tabs');
        const addOutingBtn = document.getElementById('add-outing-btn');
        const playerNameInput = document.getElementById('player-name');
        const playerSkillSlider = document.getElementById('player-skill');
        const skillValueSpan = document.getElementById('skill-value');
        const addPlayerBtn = document.getElementById('add-player-btn');
        const playerListDiv = document.getElementById('player-list');
        const numGroupsSlider = document.getElementById('num-groups');
        const groupsValueSpan = document.getElementById('groups-value');
        const shakeUpBtn = document.getElementById('shake-up-btn');
        const groupDisplayDiv = document.getElementById('group-display');
        const messageArea = document.getElementById('message-area');

        // --- Application State ---
        let outings = {}; // { outingId: { name: "Outing X", players: [], numberOfGroups: 2, groups: [] } }
        let activeOutingId = null;
        let nextOutingIndex = 1;

        // --- Initialization ---
        function initializeApp() {
            loadData(); // Load data from localStorage
            if (Object.keys(outings).length === 0) {
                // If no data, create the first outing
                createNewOuting();
            } else {
                // Otherwise, render existing tabs and set the first one as active
                renderTabs();
                // Find the first outing ID (order might not be guaranteed)
                const firstOutingId = Object.keys(outings)[0];
                 if (firstOutingId) {
                    setActiveOuting(firstOutingId);
                 } else {
                     // Should not happen if outings is not empty, but handle defensively
                     createNewOuting();
                 }
            }
            setupEventListeners();
            updateUIForActiveOuting(); // Initial UI update
        }

        // --- Data Persistence (localStorage) ---
        function saveData() {
            localStorage.setItem('golfGroupData', JSON.stringify({ outings, nextOutingIndex }));
        }

        function loadData() {
            const savedData = localStorage.getItem('golfGroupData');
            if (savedData) {
                const parsedData = JSON.parse(savedData);
                outings = parsedData.outings || {};
                nextOutingIndex = parsedData.nextOutingIndex || 1;
                 // Ensure data structure integrity (optional but good)
                Object.values(outings).forEach(outing => {
                    outing.players = outing.players || [];
                    outing.numberOfGroups = outing.numberOfGroups || 2;
                    outing.groups = outing.groups || []; // Store generated groups
                });
            } else {
                 outings = {};
                 nextOutingIndex = 1;
            }
        }

        // --- Tab Management ---
        function renderTabs() {
            // Clear existing tabs except the "Add Outing" button
            tabsContainer.querySelectorAll('.tab').forEach(tab => tab.remove());

            Object.keys(outings).sort((a, b) => outings[a].name.localeCompare(outings[b].name)).forEach(outingId => {
                const outing = outings[outingId];
                const tabButton = document.createElement('button');
                tabButton.classList.add('tab', 'whitespace-nowrap', 'py-3', 'px-3', 'border-b-2', 'border-transparent', 'text-sm', 'font-medium', 'text-gray-500', 'rounded-t-md');
                tabButton.textContent = outing.name;
                tabButton.dataset.outingId = outingId;

                // Add delete button to the tab
                const deleteBtn = document.createElement('span');
                deleteBtn.textContent = ' ✖'; // Simple 'x'
                deleteBtn.classList.add('text-red-400', 'hover:text-red-600', 'ml-1', 'cursor-pointer');
                deleteBtn.onclick = (event) => {
                    event.stopPropagation(); // Prevent tab switching when clicking delete
                    if (confirm(`Are you sure you want to delete "${outing.name}"?`)) {
                        deleteOuting(outingId);
                    }
                };
                tabButton.appendChild(deleteBtn);


                if (outingId === activeOutingId) {
                    tabButton.classList.add('active');
                    tabButton.classList.remove('text-gray-500'); // Remove default text color for active
                }

                tabButton.addEventListener('click', () => setActiveOuting(outingId));
                tabsContainer.insertBefore(tabButton, addOutingBtn); // Insert before the "Add" button
            });
        }

        function setActiveOuting(outingId) {
            if (!outings[outingId]) return; // Outing doesn't exist
            activeOutingId = outingId;
            renderTabs(); // Re-render tabs to highlight the active one
            updateUIForActiveOuting(); // Update the content area
            clearMessage();
        }

         function createNewOuting() {
            const newOutingId = `outing-${Date.now()}-${Math.random().toString(16).slice(2)}`; // More unique ID
            const newOutingName = `Outing ${nextOutingIndex++}`;
            outings[newOutingId] = {
                name: newOutingName,
                players: [],
                numberOfGroups: 2, // Default number of groups
                groups: [] // Initialize empty groups array
            };
            setActiveOuting(newOutingId); // Make the new outing active
            saveData(); // Save the new state
        }

        function deleteOuting(outingIdToDelete) {
            if (!outings[outingIdToDelete]) return;

            // Remove the outing
            delete outings[outingIdToDelete];

            // If the deleted outing was the active one, select another one or create a new one
            if (activeOutingId === outingIdToDelete) {
                const remainingOutingIds = Object.keys(outings);
                if (remainingOutingIds.length > 0) {
                    setActiveOuting(remainingOutingIds[0]); // Activate the first remaining outing
                } else {
                    // No outings left, create a new default one
                    activeOutingId = null; // Reset active ID before creating new
                    createNewOuting();
                    return; // createNewOuting handles setting active and saving
                }
            }

            renderTabs(); // Update the tab display
            saveData(); // Save changes
            // No need to call updateUIForActiveOuting here if setActiveOuting was called
        }


        // --- Player Management ---
        function addPlayer() {
            const name = playerNameInput.value.trim();
            const skill = parseInt(playerSkillSlider.value, 10);

            if (!name) {
                showMessage("Please enter a player name.");
                return;
            }
             if (!activeOutingId || !outings[activeOutingId]) {
                 showMessage("Please select or add an outing first.");
                 return;
             }

            const currentOuting = outings[activeOutingId];

            // Check if player already exists (case-insensitive)
            const existingPlayer = currentOuting.players.find(p => p.name.toLowerCase() === name.toLowerCase());
            if (existingPlayer) {
                 // Update existing player's skill
                existingPlayer.skill = skill;
                 showMessage(`Updated skill level for ${name}.`, 'info');
            } else {
                // Add new player
                currentOuting.players.push({ name, skill });
            }


            playerNameInput.value = ''; // Clear input
            // Don't reset skill slider, user might add multiple players with similar skill
            updatePlayerList();
            generateAndDisplayGroups(); // Regenerate groups when player list changes
            saveData();
            clearMessage(); // Clear any previous error messages
        }

        function removePlayer(playerName) {
             if (!activeOutingId || !outings[activeOutingId]) return;
             const currentOuting = outings[activeOutingId];
            currentOuting.players = currentOuting.players.filter(p => p.name !== playerName);
            updatePlayerList();
            generateAndDisplayGroups(); // Regenerate groups
            saveData();
        }

        function updatePlayerList() {
            playerListDiv.innerHTML = ''; // Clear current list
             if (!activeOutingId || !outings[activeOutingId]) return;

            const currentOuting = outings[activeOutingId];

            if (currentOuting.players.length === 0) {
                playerListDiv.innerHTML = '<p class="text-sm text-gray-500 italic">No players added to this outing yet.</p>';
                return;
            }

            currentOuting.players
                .slice() // Create a copy to sort without modifying original
                .sort((a, b) => a.name.localeCompare(b.name)) // Sort alphabetically
                .forEach(player => {
                    const playerElement = document.createElement('div');
                    playerElement.classList.add('player-item', 'flex', 'justify-between', 'items-center', 'text-sm', 'p-1.5', 'rounded');
                    playerElement.innerHTML = `
                        <span>${player.name} (Skill: ${player.skill})</span>
                        <button class="text-red-500 hover:text-red-700 text-xs font-semibold" onclick="removePlayer('${player.name}')">Remove</button>
                    `;
                    playerListDiv.appendChild(playerElement);
            });
        }


        // --- Group Generation ---
        function generateGroups() {
            clearMessage(); // Clear previous messages
             if (!activeOutingId || !outings[activeOutingId]) {
                 showMessage("Cannot generate groups without an active outing.");
                 return []; // Return empty array if no active outing
             }

            const currentOuting = outings[activeOutingId];
            const players = currentOuting.players;
            const numGroups = currentOuting.numberOfGroups;

            if (players.length === 0) {
                showMessage("Add players before generating groups.");
                return []; // Return empty array if no players
            }
             if (numGroups <= 0) {
                  showMessage("Number of groups must be at least 1.");
                 return [];
             }

            if (numGroups > players.length) {
                showMessage("Cannot have more groups than players. Reducing number of groups.");
                currentOuting.numberOfGroups = players.length; // Adjust slider value as well
                numGroupsSlider.value = players.length;
                groupsValueSpan.textContent = players.length;
                // Continue with generation using adjusted number of groups
            }


            // Sort players by skill level (descending) to pick best players first
            const sortedPlayers = [...players].sort((a, b) => b.skill - a.skill);

            // Initialize groups
            const groups = Array.from({ length: currentOuting.numberOfGroups }, (_, i) => ({
                id: i + 1,
                players: [],
                totalSkill: 0
            }));

            // Distribute players greedily to the group with the lowest total skill
            sortedPlayers.forEach(player => {
                // Find the group with the minimum total skill
                groups.sort((a, b) => a.totalSkill - b.totalSkill);
                groups[0].players.push(player);
                groups[0].totalSkill += player.skill;
            });

             // Store the generated groups in the outing data
            currentOuting.groups = groups;
            saveData(); // Save the generated groups

            return groups;
        }


        // --- UI Updates ---
         function updateUIForActiveOuting() {
             if (!activeOutingId || !outings[activeOutingId]) {
                // Handle state where no outing is active (e.g., after deleting the last one)
                playerListDiv.innerHTML = '<p class="text-sm text-gray-500 italic">Select or add an outing.</p>';
                groupDisplayDiv.innerHTML = '<p class="text-sm text-gray-500 italic">Select or add an outing.</p>';
                // Maybe disable inputs/sliders here if desired
                return;
            }
             const currentOuting = outings[activeOutingId];

            // Update player list
            updatePlayerList();

            // Update number of groups slider and value display
            numGroupsSlider.value = currentOuting.numberOfGroups;
            groupsValueSpan.textContent = currentOuting.numberOfGroups;
            // Adjust slider max based on number of players
            numGroupsSlider.max = Math.max(1, currentOuting.players.length); // Ensure max is at least 1

             // Update group display using stored groups
            displayGroups(currentOuting.groups);
        }

        function displayGroups(groups) {
            groupDisplayDiv.innerHTML = ''; // Clear previous display

            if (!groups || groups.length === 0) {
                 if (activeOutingId && outings[activeOutingId] && outings[activeOutingId].players.length > 0) {
                     groupDisplayDiv.innerHTML = '<p class="text-gray-500 italic">Click "Generate / Shake Up Groups" to create groups.</p>';
                 } else if (activeOutingId && outings[activeOutingId]) {
                      groupDisplayDiv.innerHTML = '<p class="text-gray-500 italic">Add players first.</p>';
                 } else {
                      groupDisplayDiv.innerHTML = '<p class="text-gray-500 italic">Select or add an outing.</p>';
                 }
                return;
            }

            groups.sort((a, b) => a.id - b.id).forEach(group => { // Sort by ID for consistent display
                const groupCard = document.createElement('div');
                groupCard.classList.add('group-card', 'bg-white', 'p-4', 'rounded-lg', 'border', 'border-gray-200', 'shadow-sm');

                const totalSkill = group.players.reduce((sum, p) => sum + p.skill, 0);
                const avgSkill = group.players.length > 0 ? (totalSkill / group.players.length).toFixed(1) : 'N/A';

                let playerListHTML = group.players
                    .map(p => `<li class="text-sm text-gray-600">${p.name} (Skill: ${p.skill})</li>`)
                    .join('');
                 if (!playerListHTML) {
                     playerListHTML = '<li class="text-sm text-gray-400 italic">Empty</li>';
                 }


                groupCard.innerHTML = `
                    <h3 class="text-md font-semibold text-blue-700 mb-2">Group ${group.id}</h3>
                    <p class="text-sm text-gray-500 mb-2">Avg Skill: ${avgSkill}</p>
                    <ul class="space-y-1 list-disc list-inside">
                        ${playerListHTML}
                    </ul>
                `;
                groupDisplayDiv.appendChild(groupCard);
            });
        }

        function generateAndDisplayGroups() {
            const generatedGroups = generateGroups();
            displayGroups(generatedGroups);
        }

        // --- Utility Functions ---
        function showMessage(message, type = 'error') {
            messageArea.textContent = message;
            messageArea.className = `mt-4 text-center font-medium ${type === 'error' ? 'text-red-600' : 'text-blue-600'}`;
        }

        function clearMessage() {
            messageArea.textContent = '';
        }

        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Update skill value display when slider changes
            playerSkillSlider.addEventListener('input', () => {
                skillValueSpan.textContent = playerSkillSlider.value;
            });

            // Add player on button click
            addPlayerBtn.addEventListener('click', addPlayer);
            // Add player on Enter key in name input
             playerNameInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    addPlayer();
                }
            });


            // Update number of groups and regenerate groups when slider changes
            numGroupsSlider.addEventListener('input', () => {
                groupsValueSpan.textContent = numGroupsSlider.value;
                 if (activeOutingId && outings[activeOutingId]) {
                    outings[activeOutingId].numberOfGroups = parseInt(numGroupsSlider.value, 10);
                    // Regenerate immediately or wait for button click? Let's wait for button.
                    // generateAndDisplayGroups(); // Option: Regenerate on slider change
                    saveData(); // Save the new number of groups setting
                 }
            });

            // Regenerate groups on "Shake Up" button click
            shakeUpBtn.addEventListener('click', generateAndDisplayGroups);

            // Add new outing tab
            addOutingBtn.addEventListener('click', createNewOuting);
        }

        // --- Global Event Listener (for dynamically added elements like remove buttons) ---
        // Using event delegation is more robust, but for simplicity with direct onclick:
        // Make removePlayer globally accessible (it already is)

        // --- Start the application ---
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>

</body>
</html>
